apply plugin: 'jacoco'
apply plugin: 'pmd'
apply plugin: 'findbugs'
apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'eclipse'
apply plugin: 'idea'

def projectURI = null

if (project.hasProperty('local')) {
    logger.info('Building using local properties.')

    projectURI = rootProject.projectDir.toURI().toURL()
} else {
    logger.info('Building using remote properties.')

    projectURI = 'https://raw.github.com/abhijitsarkar/build-tools/master/gradle-common'
}

def props = new Properties()
new URL("${projectURI}/gradle.properties").withInputStream {
    stream -> props.load(stream)
}

sourceCompatibility = props.projectSourceCompatibility
targetCompatibility = props.projectSourceCompatibility

group = props.projectGroup
version = props.projectVersion

repositories {
    mavenCentral()
}

if (!rootProject.ext.has('pmdRuleSetLocation')) {
    ext.set('pmdRuleSetLocation', "${System.properties['java.io.tmpdir']}/${UUID.randomUUID().toString()}/ruleset.xml")
}

pmd {
    toolVersion = props.pmdVersion
    sourceSets = [sourceSets.main]
    ignoreFailures = true
    ruleSetFiles = files(rootProject.pmdRuleSetLocation)
}

/* The download task should only be added to the root project. If a multimodule project imports this file within a
 * 'subprojects' block, it's going to end up with as many copies of the download task as there are submodules. Because
 * of the way Gradle task up-to-date works, each submodule is going to download the file the first time, even though
 * they are all downloading the same file. Next time onwards, they're not going to download. If there are many
 * submodules, this could incur some unnecessary overhead.
 * http://www.gradle.org/docs/current/userguide/more_about_tasks.html
 */
if (!rootProject.tasks.findByName('downloadPmdRuleSet')) {
    rootProject.tasks.create('downloadPmdRuleSet', {
        def pmdRuleSetLocation = file(rootProject.pmdRuleSetLocation)

        it.onlyIf { !pmdRuleSetLocation.exists() }

        outputs.file pmdRuleSetLocation

        doLast {
            def src = "${projectURI}/src/main/conf/pmd/ruleset.xml"

            pmdRuleSetLocation.parentFile.mkdirs()

            println "Downloading ${src} to ${pmdRuleSetLocation.absolutePath}."

            ant.get(src: "${src}", dest: pmdRuleSetLocation.absolutePath)
        }
    })
}

tasks.withType(Pmd) {
    it.dependsOn rootProject.tasks['downloadPmdRuleSet']

    it.onlyIf { !project.hasProperty('skipCoverage') }
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

findbugs {
    toolVersion = props.findbugsVersion
    sourceSets = [sourceSets.main]
    ignoreFailures = true
    reportsDir = file("${buildDir}/reports/findbugs")
    effort = 'default'
}

tasks.withType(FindBugs) {
    it.onlyIf { !project.hasProperty('skipCoverage') }
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

jacoco {
    toolVersion = props.jacocoVersion
}

jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.destination "${buildDir}/reports/jacoco"
    }
}

tasks.withType(Test) { task ->
//    jacoco {
//        destinationFile = file("$buildDir/reports/jacoco/${task.name}.exec")
//    }
    reports {
//        junitXml.enabled = true
        html.enabled = true
    }
}

compileJava.options.encoding = 'UTF-8'

dependencies {
    compileOnly(
            "org.slf4j:slf4j-api:${props.slf4jVersion}",
            "ch.qos.logback:logback-core:${props.logbackVersion}",
            "ch.qos.logback:logback-classic:${props.logbackVersion}",
            /* Add this in case client project attempts to suppress findbugs warnings for Lombok generated classes */
            "com.google.code.findbugs:findbugs:${props.findbugsVersion}",
            "org.projectlombok:lombok:${props.lombokVersion}"
    )
    testCompile(
            "junit:junit:${props.junitVersion}",
            "org.hamcrest:hamcrest-all:${props.hamcrestVersion}",
            "org.codehaus.groovy:groovy:${props.groovyVersion}"
    )
    pmd(
            "net.sourceforge.pmd:pmd-core:${props.pmdVersion}",
            "net.sourceforge.pmd:pmd-java8:${props.pmdVersion}"
    )
    findbugs("com.google.code.findbugs:findbugs:${props.findbugsVersion}")

    jacocoAnt("org.jacoco:org.jacoco.ant:${props.jacocoVersion}")
    jacocoAgent("org.jacoco:org.jacoco.agent:${props.jacocoVersion}")
}

def integrationTestDir = relativePath("${projectDir}/src/integration-test")

sourceSets {
    integrationTest {
        java {
            srcDir "${integrationTestDir}/java"
        }
        groovy {
            srcDir "${integrationTestDir}/groovy"
        }
        resources {
            srcDir "${integrationTestDir}/resources"
        }
        compileClasspath += (sourceSets.main.compileClasspath + sourceSets.test.compileClasspath)
        runtimeClasspath += (sourceSets.main.runtimeClasspath + sourceSets.test.runtimeClasspath)
    }

    [main, test, integrationTest].each {
        it.output.resourcesDir = project.file("$buildDir/classes/${it.name}")
    }
}


task integrationTest(type: Test, dependsOn: test) {
    onlyIf { !project.hasProperty('skipIT') }

    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
}

//testResultsDirName = "reports/junit"
//testReportDirName = "junit"

build.dependsOn integrationTest

jar {
    manifest {
        attributes(
                'Implementation-Vendor': 'Abhijit Sarkar',
                'Implementation-Version': version
        )
    }
}

rootProject.tasks['wrapper'].configure {
    gradleVersion = props.gradleVersion
    distributionUrl = props.gradleDownloadUrl
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

artifacts {
    archives javadocJar, sourcesJar
}
