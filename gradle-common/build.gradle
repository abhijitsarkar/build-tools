apply plugin: 'jacoco'
apply plugin: 'pmd'
apply plugin: 'findbugs'
apply plugin: 'java'

def projectURI = null

if (project.hasProperty('local')) {
    logger.info('Building using local properties.')

    projectURI = rootProject.projectDir.toURI().toURL()
} else {
    logger.info('Building using remote properties.')

    projectURI = 'https://raw.github.com/abhijitsarkar/build-tools/master/gradle-common'
}

def props = new Properties()
new URL("${projectURI}/gradle.properties").withInputStream {
    stream -> props.load(stream)
}

sourceCompatibility = props.projectSourceCompatibility
targetCompatibility = props.projectSourceCompatibility

group = props.projectGroup
version = props.projectVersion

repositories {
    mavenCentral()
}

def pmdRuleSetLocation = file("${System.properties['java.io.tmpdir']}/gradle-common/ruleset.xml")

pmd {
    toolVersion = props.pmdVersion
    sourceSets = [sourceSets.main]
    ignoreFailures = true
    ruleSetFiles = files(pmdRuleSetLocation)
}

/* The download task should only be added to the root project. If a multimodule project imports this file within a
 * 'subprojects' block, it's going to end up with as many copies of the download task as there are submodules. Because
 * of the way Gradle task up-to-date works, each submodule is going to download the file the first time, even though
 * they are all downloading the same file. Next time onwards, they're not going to download. If there are many
 * submodules, this could incur some unnecessary overhead.
 * http://www.gradle.org/docs/current/userguide/more_about_tasks.html
 */
if (!rootProject.tasks.findByName('downloadPmdRuleSet')) {
    rootProject.tasks.create('downloadPmdRuleSet', {
        outputs.file pmdRuleSetLocation

        doLast {
            def src = "${projectURI}/src/main/config/pmd/ruleset.xml"

            pmdRuleSetLocation.parentFile.mkdirs()

            println "Downloading ${src} to ${pmdRuleSetLocation.absolutePath}."

            ant.get(src: "${src}", dest: pmdRuleSetLocation.absolutePath)
        }
    })
}

tasks.withType(Pmd) {
    it.dependsOn rootProject.tasks['downloadPmdRuleSet']

    it.onlyIf { !project.hasProperty('skipCoverage') }
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

findbugs {
    toolVersion = props.findbugsVersion
    sourceSets = [sourceSets.main]
    ignoreFailures = true
    reportsDir = file("${buildDir}/reports/findbugs")
    effort = 'default'
}

tasks.withType(FindBugs) {
    it.onlyIf { !project.hasProperty('skipCoverage') }
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

jacoco {
    toolVersion = props.jacocoVersion
}

jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.destination "${buildDir}/reports/jacoco"
    }
}

dependencies {
    compileOnly(
            "org.slf4j:slf4j-api:${props.slf4jVersion}",
            "ch.qos.logback:logback-core:${props.logbackVersion}",
            "ch.qos.logback:logback-classic:${props.logbackVersion}",
            /* Add this in case client project attempts to suppress findbugs warnings for Lombok generated classes */
            "com.google.code.findbugs:findbugs:${props.findbugsVersion}"
    )
    testCompile(
            "junit:junit:${props.junitVersion}"
    )
    pmd(
            "net.sourceforge.pmd:pmd-core:${props.pmdVersion}",
            "net.sourceforge.pmd:pmd-java8:${props.pmdVersion}"
    )
    findbugs("com.google.code.findbugs:findbugs:${props.findbugsVersion}")

    jacocoAnt("org.jacoco:org.jacoco.ant:${props.jacocoVersion}")
    jacocoAgent("org.jacoco:org.jacoco.agent:${props.jacocoVersion}")
}

sourceSets {
    [main, test].each {
        it.output.resourcesDir = project.file("$buildDir/classes/${it.name}")
    }
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

artifacts {
    archives javadocJar, sourcesJar
}

jar { manifest.attributes provider: 'Abhijit Sarkar' }

rootProject.tasks['wrapper'].configure {
    gradleVersion = props.gradleVersion
}
